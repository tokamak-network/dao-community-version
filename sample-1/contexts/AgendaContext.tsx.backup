"use client";

import React, {
  createContext,
  useContext,
  useEffect,
  useState,
  ReactNode,
  useCallback,
  useMemo,
} from "react";
import { useAccount } from 'wagmi';
import {
  AgendaWithMetadata,
  AgendaCreatedEvent,
  AgendaAction,
} from "@/types/agenda";
import { CONTRACTS, CONTRACT_READ_SETTINGS } from "@/config/contracts";
import { daoAgendaManagerAbi } from "@/abis/dao-agenda-manager";
import { DAO_ABI } from "@/abis/dao";
import { chain } from "@/config/chain";
import { createRobustPublicClient, readContractWithRetry } from "@/lib/rpc-utils";
import { MESSAGES, AGENDA_STATUS } from "@/constants/dao";
import { createPublicClient, http } from "viem";
import {
  getAllAgendaMetadata,
  fetchAgendaEvents,
  getLatestBlockNumber,
  getNetworkName,
  getMetadataUrl,
  AgendaMetadata
} from "@/lib/utils";

interface AgendaContextType {
  agendas: AgendaWithMetadata[];
  isLoading: boolean;
  error: string | null;
  refreshAgendas: () => Promise<void>;
  refreshAgenda: (agendaId: number) => Promise<void>;
  refreshAgendaWithoutCache: (agendaId: number) => Promise<AgendaWithMetadata | null>;
  getAgenda: (agendaId: number) => Promise<AgendaWithMetadata | null>;
  statusMessage: string;
  contract: {
    address: `0x${string}`;
    abi: any;
    chainId: number;
  };
  daoContract: {
    address: `0x${string}`;
    abi: any;
    chainId: number;
  };
  events: AgendaCreatedEvent[];
  isPolling: boolean;
  progress: {
    current: bigint;
    total: bigint;
    percentage: number;
  } | null;
  createAgendaFees: bigint | null;
  minimumNoticePeriodSeconds: bigint | null;
  minimumVotingPeriodSeconds: bigint | null;
  quorum: bigint | null;
  getVoterInfos: (
    agendaId: number,
    voters: string[]
  ) => Promise<
    {
      isVoter: boolean;
      hasVoted: boolean;
      vote: bigint;
    }[]
  >;
  getTransactionData: (txHash: string) => Promise<string | null>;
  updateAgendaCalldata: (agendaId: number) => Promise<void>;
}

const AgendaContext = createContext<AgendaContextType | undefined>(undefined);

// Creator ì •ë³´ ì²˜ë¦¬ í—¬í¼ í•¨ìˆ˜ë“¤
const isCreatorString = (creator: unknown): creator is `0x${string}` => {
  return typeof creator === "string" && creator.startsWith("0x");
};

const isCreatorObject = (
  creator: unknown
): creator is { address: `0x${string}`; signature?: string } => {
  return (
    typeof creator === "object" &&
    creator !== null &&
    "address" in creator &&
    typeof (creator as any).address === "string" &&
    (creator as any).address.startsWith("0x")
  );
};

const getCreatorAddress = (creator: unknown): `0x${string}` => {
  if (isCreatorString(creator)) {
    return creator as `0x${string}`;
  }
  if (isCreatorObject(creator)) {
    return creator.address as `0x${string}`;
  }
  return "0x0000000000000000000000000000000000000000" as `0x${string}`;
};

const getCreatorSignature = (creator: unknown): string | undefined => {
  if (isCreatorObject(creator)) {
    return creator.signature;
  }
  return undefined;
};

// ì•„ì  ë‹¤ ìƒíƒœ í…ìŠ¤íŠ¸ ë³€í™˜
const getAgendaStatusText = (status: number): string => {
  switch (status) {
    case 1: return "NOTICE";
    case 2: return "VOTING";
    case 3: return "WAITING EXECUTION";
    case 4: return "EXECUTED";
    case 5: return "ENDED";
    default: return "UNKNOWN";
  }
};

// ì•„ì  ë‹¤ ìƒíƒœ ìƒ‰ìƒ
const getAgendaStatusColor = (status: number): string => {
  switch (status) {
    case 1: return "yellow"; // NOTICE
    case 2: return "purple"; // VOTING
    case 3: return "blue"; // WAITING EXECUTION
    case 4: return "green"; // EXECUTED
    case 5: return "red"; // ENDED
    default: return "gray";
  }
};

const AgendaProviderComponent = React.memo(({ children }: { children: ReactNode }) => {
  const { address, isConnected } = useAccount();

  console.log("ğŸ—ï¸ AgendaProvider ë§ˆìš´íŠ¸ë¨", {
    timestamp: new Date().toLocaleTimeString(),
    isConnected,
    address
  });

  // ìƒíƒœ ê´€ë¦¬
  const [agendas, setAgendas] = useState<AgendaWithMetadata[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [statusMessage, setStatusMessage] = useState("");
  const [hasLoadedOnce, setHasLoadedOnce] = useState(false);
  const [events, setEvents] = useState<AgendaCreatedEvent[]>([]);
  const [isPolling, setIsPolling] = useState(true);
  const [progress, setProgress] = useState<{
    current: bigint;
    total: bigint;
    percentage: number;
  } | null>(null);

  // ì»¨íŠ¸ë™íŠ¸ ì„¤ì •ê°’ë“¤
  const [createAgendaFees, setCreateAgendaFees] = useState<bigint | null>(null);
  const [minimumNoticePeriodSeconds, setMinimumNoticePeriodSeconds] = useState<bigint | null>(null);
  const [minimumVotingPeriodSeconds, setMinimumVotingPeriodSeconds] = useState<bigint | null>(null);
  const [quorum, setQuorum] = useState<bigint | null>(null);
  const [committeeMembers, setCommitteeMembers] = useState<string[]>([]);

  // Runtime checks for contract addresses
  if (!CONTRACTS.daoAgendaManager.address) {
    throw new Error('DAO_AGENDA_MANAGER_ADDRESS is not configured');
  }
  if (!CONTRACTS.daoCommittee.address) {
    throw new Error('DAO_COMMITTEE_PROXY_ADDRESS is not configured');
  }

  // ì»¨íŠ¸ë™íŠ¸ ì„¤ì •ê°’ë“¤ ë¡œë“œ
  useEffect(() => {
    const loadContractSettings = async () => {
      try {
        const publicClient = await createRobustPublicClient();

        // AgendaManagerì—ì„œ ì„¤ì •ê°’ë“¤ ê°€ì ¸ì˜¤ê¸°
        const [fees, minNotice, minVoting] = await Promise.all([
          readContractWithRetry(
            () => publicClient.readContract({
              address: CONTRACTS.daoAgendaManager.address as `0x${string}`,
              abi: daoAgendaManagerAbi,
              functionName: 'createAgendaFees',
            }) as Promise<bigint>,
            'Create agenda fees'
          ),
          readContractWithRetry(
            () => publicClient.readContract({
              address: CONTRACTS.daoAgendaManager.address as `0x${string}`,
              abi: daoAgendaManagerAbi,
              functionName: 'minimumNoticePeriodSeconds',
            }) as Promise<bigint>,
            'Minimum notice period'
          ),
          readContractWithRetry(
            () => publicClient.readContract({
              address: CONTRACTS.daoAgendaManager.address as `0x${string}`,
              abi: daoAgendaManagerAbi,
              functionName: 'minimumVotingPeriodSeconds',
            }) as Promise<bigint>,
            'Minimum voting period'
          ),
        ]);

        setCreateAgendaFees(fees);
        setMinimumNoticePeriodSeconds(minNotice);
        setMinimumVotingPeriodSeconds(minVoting);

        // DAO Committeeì—ì„œ quorum ê°€ì ¸ì˜¤ê¸°
        const quorumValue = await readContractWithRetry(
          () => publicClient.readContract({
            address: CONTRACTS.daoCommittee.address as `0x${string}`,
            abi: DAO_ABI,
            functionName: 'quorum',
          }) as Promise<bigint>,
          'Quorum value'
        );
        setQuorum(quorumValue);

      } catch (error) {
        console.error('Failed to load contract settings:', error);
      }
    };

    loadContractSettings();
  }, []);

  // ìœ„ì›íšŒ ë©¤ë²„ ì •ë³´ ë¡œë“œ
  useEffect(() => {
    const loadCommitteeMembers = async () => {
      try {
        const publicClient = await createRobustPublicClient();

        // maxMember ê°€ì ¸ì˜¤ê¸°
        const maxMember = await readContractWithRetry(
          () => publicClient.readContract({
            address: CONTRACTS.daoCommittee.address as `0x${string}`,
            abi: DAO_ABI,
            functionName: 'maxMember',
          }) as Promise<bigint>,
          'Max member count'
        );

        const members: string[] = [];
        for (let i = 0; i < Number(maxMember); i++) {
          try {
            const member = await readContractWithRetry(
              () => publicClient.readContract({
                address: CONTRACTS.daoCommittee.address as `0x${string}`,
                abi: DAO_ABI,
                functionName: 'members',
                args: [BigInt(i)],
              }) as Promise<string>,
              `Member at slot ${i}`
            );

            if (member && member !== '0x0000000000000000000000000000000000000000') {
              members.push(member);
            }
          } catch (error) {
            // ë¹ˆ ìŠ¬ë¡¯ì€ ë¬´ì‹œ
            continue;
          }
        }

        setCommitteeMembers(members);
      } catch (error) {
        console.error('Failed to load committee members:', error);
      }
    };

    loadCommitteeMembers();
  }, []);

  // ì•„ì  ë‹¤ ë¡œë“œ í•¨ìˆ˜
  const loadAgendas = useCallback(async () => {
    setIsLoading(true);
    setError(null);
    setStatusMessage(MESSAGES.LOADING.AGENDAS);

    try {
      const publicClient = await createRobustPublicClient();

      // ì´ ì•„ì  ë‹¤ ê°œìˆ˜ ê°€ì ¸ì˜¤ê¸°
      const numAgendas = await readContractWithRetry(
        () => publicClient.readContract({
          address: CONTRACTS.daoAgendaManager.address as `0x${string}`,
          abi: daoAgendaManagerAbi,
          functionName: 'numAgendas',
        }) as Promise<bigint>,
        'Total agendas count'
      );

      const totalAgendas = Number(numAgendas);
      console.log('ğŸ“Š Total agendas:', totalAgendas);

      if (totalAgendas === 0) {
        setAgendas([]);
        setHasLoadedOnce(true);
        setStatusMessage("No agendas found");
        return;
      }

      // ê° ì•„ì  ë‹¤ ë°ì´í„° ê°€ì ¸ì˜¤ê¸° (ìµœì‹ ìˆœìœ¼ë¡œ ì²˜ë¦¬)
      const { BATCH_SIZE, BATCH_DELAY_MS } = CONTRACT_READ_SETTINGS;

      for (let i = totalAgendas - 1; i >= 0; i -= BATCH_SIZE) {
        const startIndex = Math.max(0, i - BATCH_SIZE + 1);
        const currentBatch = i - startIndex + 1;
        const progress = Math.round(((totalAgendas - i) / totalAgendas) * 100);

        setStatusMessage(`Loading agendas... (${totalAgendas - i}/${totalAgendas}) [${progress}%]`);

        const batchPromises = Array.from({ length: currentBatch }, (_, j) => {
          const agendaId = i - j; // ìµœì‹ ìˆœìœ¼ë¡œ ê°€ì ¸ì˜¤ê¸°
          return readContractWithRetry(
            () => publicClient.readContract({
              address: CONTRACTS.daoAgendaManager.address as `0x${string}`,
              abi: daoAgendaManagerAbi,
              functionName: 'agendas',
              args: [BigInt(agendaId)],
            }) as Promise<{
              createdTimestamp: bigint;
              noticeEndTimestamp: bigint;
              votingPeriodInSeconds: bigint;
              votingStartedTimestamp: bigint;
              votingEndTimestamp: bigint;
              executableLimitTimestamp: bigint;
              executedTimestamp: bigint;
              countingYes: bigint;
              countingNo: bigint;
              countingAbstain: bigint;
              status: number;
              result: number;
              voters: readonly string[];
              executed: boolean;
            }>,
            `Agenda ${agendaId}`
          ).then((agendaData) => {
            // AgendaWithMetadata ì¸í„°í˜ì´ìŠ¤ì— ë§ê²Œ ë³€í™˜
            const agenda: AgendaWithMetadata = {
              ...agendaData,
              id: agendaId,
              voters: Array.from(agendaData.voters),
              creator: {
                address: "0x0000000000000000000000000000000000000000" as `0x${string}`,
                signature: ""
              }
            };

            return agenda;
          }).catch((error) => {
            console.warn(`Failed to fetch agenda ${agendaId}:`, error);
            return null;
          });
        });

        const batchResults = await Promise.all(batchPromises);
        const validResults = batchResults.filter((result): result is AgendaWithMetadata => result !== null);

        // ë©”íƒ€ë°ì´í„° ë¡œë”© (ë°°ì¹˜ ë‹¨ìœ„ë¡œ)
        const agendaIds = validResults.map(agenda => agenda.id);
        if (agendaIds.length > 0) {
          try {
            const metadataMap = await getAllAgendaMetadata(agendaIds);

                        // ë©”íƒ€ë°ì´í„°ë¥¼ ì•„ì  ë‹¤ ë°ì´í„°ì™€ ê²°í•©
            validResults.forEach((agenda) => {
              const metadata = metadataMap[agenda.id];
              if (metadata) {
                agenda.title = metadata.title || agenda.title;
                agenda.description = metadata.description || agenda.description;
                agenda.creator = {
                  address: getCreatorAddress(metadata.creator),
                  signature: getCreatorSignature(metadata.creator),
                };
                agenda.snapshotUrl = metadata.snapshotUrl;
                agenda.discourseUrl = metadata.discourseUrl;
                agenda.network = metadata.network;
                agenda.transaction = metadata.transaction;
                agenda.actions = metadata.actions;
              }
            });

            // ìˆœì°¨ì ìœ¼ë¡œ calldata ê°€ì ¸ì˜¤ê¸° (rate limiting ë°©ì§€)
            for (const agenda of validResults) {
              const metadata = metadataMap[agenda.id];
              if (metadata?.transaction && !agenda.creationCalldata) {
                try {
                  const calldata = await getTransactionData(metadata.transaction);
                  if (calldata) {
                    agenda.creationCalldata = calldata;
                  }
                  // Rate limitingì„ ìœ„í•œ ì§§ì€ ëŒ€ê¸°
                  await new Promise(resolve => setTimeout(resolve, 100));
                } catch (error) {
                  console.warn(`Failed to fetch calldata for agenda ${agenda.id}:`, error);
                }
              }
            }
          } catch (error) {
            console.warn('Failed to load metadata for batch:', error);
          }
        }
        console.log(validResults)
        // ë°°ì¹˜ ê²°ê³¼ë¥¼ ì¦‰ì‹œ ìƒíƒœì— ì¶”ê°€ (ì ì§„ì  í‘œì‹œ)
        setAgendas((prev) => {
          const existingAgendas = new Map(prev.map((a) => [a.id, a]));
          let hasChanges = false;

          validResults.forEach((newAgenda) => {
            const existingAgenda = existingAgendas.get(newAgenda.id);
            if (!existingAgenda) {
              existingAgendas.set(newAgenda.id, newAgenda);
              hasChanges = true;
            } else {
              // BigInt ê°’ì„ ë¬¸ìì—´ë¡œ ë³€í™˜í•˜ì—¬ ë¹„êµ
              const existingStr = JSON.stringify(existingAgenda, (key, value) =>
                typeof value === "bigint" ? value.toString() : value
              );
              const newStr = JSON.stringify(newAgenda, (key, value) =>
                typeof value === "bigint" ? value.toString() : value
              );

              if (existingStr !== newStr) {
                existingAgendas.set(newAgenda.id, newAgenda);
                hasChanges = true;
              }
            }
          });

          return hasChanges
            ? Array.from(existingAgendas.values()).sort((a, b) => b.id - a.id)
            : prev;
        });

        // ë§ˆì§€ë§‰ ë°°ì¹˜ê°€ ì•„ë‹ˆë©´ ì ì‹œ ëŒ€ê¸° (Rate limiting)
        if (startIndex > 0) {
          await new Promise(resolve => setTimeout(resolve, BATCH_DELAY_MS));
        }
      }
      setHasLoadedOnce(true);
      setStatusMessage(`Loaded ${totalAgendas} agendas from AgendaManager contract`);

    } catch (err) {
      console.error("Failed to load agendas from AgendaManager:", err);
      setError("Failed to load agendas from blockchain");
      setStatusMessage("Error loading agendas from AgendaManager contract");
      setAgendas([]);
    } finally {
      setIsLoading(false);
    }
  }, []);

  // ì´ë²¤íŠ¸ ë¡œë”© í•¨ìˆ˜
  const fetchEvents = useCallback(async () => {
    let isMounted = true;
    let allFetchedEvents = false;
    let abortController = new AbortController();

    const startBlock = BigInt(process.env.NEXT_PUBLIC_EVENT_START_BLOCK || "0");
    const blockRange = BigInt(process.env.NEXT_PUBLIC_BLOCK_RANGE || "500");
    let fromBlock = startBlock;
    let toBlock = fromBlock + blockRange;

    try {
      const latestBlock = BigInt(await getLatestBlockNumber());
      const totalBlocks = latestBlock - startBlock;
      const publicClient = createPublicClient({
        chain: {
          id: chain.id,
          name: chain.name,
          nativeCurrency: chain.nativeCurrency,
          rpcUrls: chain.rpcUrls,
        },
        transport: http(process.env.NEXT_PUBLIC_RPC_URL as string),
      });

      while (
        toBlock < latestBlock &&
        isMounted &&
        !allFetchedEvents &&
        !abortController.signal.aborted
      ) {
        try {
          const fetchedEvents = await fetchAgendaEvents(
            {
              address: CONTRACTS.daoAgendaManager.address as `0x${string}`,
              abi: daoAgendaManagerAbi,
              chainId: chain.id,
            },
            fromBlock,
            toBlock,
            publicClient
          );

          if (!isMounted || abortController.signal.aborted) break;

          if (fetchedEvents.length > 0) {
            fetchedEvents.forEach((event: { args?: AgendaCreatedEvent }) => {
              if (
                !event.args?.id ||
                !event.args?.noticePeriodSeconds ||
                !event.args?.votingPeriodSeconds
              ) {
                return;
              }
              const eventArgs = event.args;
              setEvents((prev) => [...prev, eventArgs]);
            });
          }

          const progressData = {
            current: toBlock,
            total: totalBlocks,
            percentage: Number(
              ((toBlock - startBlock) * BigInt(100)) / totalBlocks
            ),
          };
          setProgress(progressData);

          fromBlock = toBlock;
          toBlock = fromBlock + blockRange;
          if (toBlock >= latestBlock) {
            toBlock = latestBlock;
          }

          if (fromBlock === toBlock || fromBlock > latestBlock) {
            allFetchedEvents = true;
          }

          await new Promise((resolve) => {
            const timeoutId = setTimeout(
              resolve,
              CONTRACT_READ_SETTINGS.BATCH_DELAY_MS
            );
            abortController.signal.addEventListener("abort", () => {
              clearTimeout(timeoutId);
              resolve(null);
            });
          });
        } catch (err) {
          if (!isMounted || abortController.signal.aborted) break;
          console.error("Error in fetch loop:", err);
          break;
        }
      }
    } catch (err) {
      if (!isMounted || abortController.signal.aborted) return;
      console.error("Error fetching events:", err);
      setError("Failed to fetch events. Please try again later.");
    } finally {
      if (isMounted && !abortController.signal.aborted) {
        setProgress(null);
        setIsPolling(false);
      }
      allFetchedEvents = true;
    }

    return () => {
      isMounted = false;
      abortController.abort();
    };
  }, []);

  // ì´ˆê¸° ì•„ì  ë‹¤ ë¡œë“œ
  useEffect(() => {
    if (!hasLoadedOnce) {
      loadAgendas();
    }
  }, [hasLoadedOnce, loadAgendas]);

  // ì´ë²¤íŠ¸ ë¡œë”© ì‹œì‘
  useEffect(() => {
    if (hasLoadedOnce && agendas.length > 0) {
      fetchEvents();
    }
  }, [hasLoadedOnce, agendas.length, fetchEvents]);

  // ì´ë²¤íŠ¸ì™€ ì•„ì  ë‹¤ ê²°í•©í•˜ëŠ” í•¨ìˆ˜
  const updateAgendasWithCreatorInfo = useCallback((
    agendas: AgendaWithMetadata[],
    events: AgendaCreatedEvent[]
  ) => {
    return agendas.map((agenda) => {
      const event = events.find((e) => Number(e.id) === agenda.id);
      if (event) {
        return {
          ...agenda,
          creator: {
            address: event.from,
            signature: agenda.creator?.signature,
          },
        } as AgendaWithMetadata;
      }
      return agenda;
    });
  }, []);

  // ì‹¤ì‹œê°„ ì•„ì  ë‹¤ ë°ì´í„° ì—…ë°ì´íŠ¸ í•¨ìˆ˜ (sample-2ì—ì„œ ê°€ì ¸ì˜´)
  const updateAgendaData = useCallback(async (
    agendaId: number,
    shouldSort: boolean = false
  ) => {
    console.log("ğŸ”„ updateAgendaData - Starting update for agenda ID:", agendaId);

    try {
      const publicClient = await createRobustPublicClient();

      // ì•„ì  ë‹¤ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
      console.log("ğŸ“Š updateAgendaData - Fetching contract data...");
      const agendaData = await readContractWithRetry(
        () => publicClient.readContract({
          address: CONTRACTS.daoAgendaManager.address as `0x${string}`,
          abi: daoAgendaManagerAbi,
          functionName: 'agendas',
          args: [BigInt(agendaId)],
        }) as Promise<{
          createdTimestamp: bigint;
          noticeEndTimestamp: bigint;
          votingPeriodInSeconds: bigint;
          votingStartedTimestamp: bigint;
          votingEndTimestamp: bigint;
          executableLimitTimestamp: bigint;
          executedTimestamp: bigint;
          countingYes: bigint;
          countingNo: bigint;
          countingAbstain: bigint;
          status: number;
          result: number;
          voters: readonly string[];
          executed: boolean;
        }>,
        `Update agenda ${agendaId}`
      );
      console.log("âœ… updateAgendaData - Contract data received:", agendaData);

      // ë©”íƒ€ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
      console.log("ğŸ“„ updateAgendaData - Fetching metadata...");
      let metadata: AgendaMetadata | null = null;
      try {
        const networkName = getNetworkName(chain.id);
        const metadataUrl = getMetadataUrl(agendaId, networkName);
        console.log("ğŸ”— updateAgendaData - Metadata URL:", metadataUrl);

        const response = await fetch(metadataUrl, {
          cache: "no-store", // ìºì‹œ ë¹„í™œì„±í™”
        });

        if (response.ok) {
          metadata = await response.json();
          console.log("âœ… updateAgendaData - Metadata received:", metadata);
        } else {
          console.log("âš ï¸ updateAgendaData - No metadata found");
        }
      } catch (error) {
        console.warn(`âš ï¸ Failed to load metadata for agenda ${agendaId}:`, error);
      }

      // ìƒíƒœ ì—…ë°ì´íŠ¸
      setAgendas((prevAgendas) => {
        console.log("ğŸ“‹ updateAgendaData - Previous agendas count:", prevAgendas.length);
        console.log("ğŸ” updateAgendaData - Previous agenda IDs:", prevAgendas.map((a) => a.id));

        // ê¸°ì¡´ ì•„ì  ë‹¤ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
        const existingAgenda = prevAgendas.find((a) => a.id === agendaId);
        console.log("ğŸ” updateAgendaData - Existing agenda found:", !!existingAgenda);

        // ì•„ì  ë‹¤ ë°ì´í„°ì™€ ë©”íƒ€ë°ì´í„° ê²°í•©
        const updatedAgenda: AgendaWithMetadata = {
          ...agendaData,
          id: agendaId,
          voters: Array.from(agendaData.voters),
          title: metadata?.title || existingAgenda?.title || `Agenda #${agendaId}`,
          description: metadata?.description || existingAgenda?.description || `Agenda ${agendaId} from blockchain`,
          creator: {
            address: metadata ? getCreatorAddress(metadata.creator) : (existingAgenda?.creator?.address || "0x0000000000000000000000000000000000000000" as `0x${string}`),
            signature: metadata ? getCreatorSignature(metadata.creator) : existingAgenda?.creator?.signature,
          },
          snapshotUrl: metadata?.snapshotUrl || existingAgenda?.snapshotUrl,
          discourseUrl: metadata?.discourseUrl || existingAgenda?.discourseUrl,
          network: metadata?.network || existingAgenda?.network,
          transaction: metadata?.transaction || existingAgenda?.transaction,
          actions: metadata?.actions || existingAgenda?.actions,
        };
        console.log("âœ… updateAgendaData - Combined data:", updatedAgenda);

        const existingAgendas = new Map(prevAgendas.map((a) => [a.id, a]));
        existingAgendas.set(agendaId, updatedAgenda);
        const newAgendas = Array.from(existingAgendas.values());
        const finalAgendas = shouldSort
          ? newAgendas.sort((a, b) => b.id - a.id)
          : newAgendas;

        console.log("ğŸ“Š updateAgendaData - New agendas count:", finalAgendas.length);
        console.log("ğŸ” updateAgendaData - New agenda IDs:", finalAgendas.map((a) => a.id));
        console.log("ğŸ”„ updateAgendaData - Should sort:", shouldSort);

        return finalAgendas;
      });

      console.log("âœ… updateAgendaData - Agenda data update completed for ID:", agendaId);
    } catch (error) {
      console.error("âŒ updateAgendaData - Error updating agenda data:", error);
    }
  }, []);

  // ì´ë²¤íŠ¸ê°€ ë³€ê²½ë  ë•Œë§ˆë‹¤ ì•„ì  ë‹¤ ëª©ë¡ ì—…ë°ì´íŠ¸
  useEffect(() => {
    if (events.length > 0 && agendas.length > 0) {
      const updatedAgendas = updateAgendasWithCreatorInfo(agendas, events);
      setAgendas(updatedAgendas);
    }
  }, [events, updateAgendasWithCreatorInfo]);

  // ì‹¤ì‹œê°„ ì´ë²¤íŠ¸ ê°ì§€ (sample-2ì—ì„œ ê°€ì ¸ì˜´)
  useEffect(() => {
    console.log("ğŸš€ Real-time events - useEffect ì‹¤í–‰ë¨", {
      timestamp: new Date().toISOString(),
      chainId: chain.id,
      contractAddress: CONTRACTS.daoAgendaManager.address,
      hasUpdateAgendaData: !!updateAgendaData,
      updateAgendaDataType: typeof updateAgendaData
    });

    console.log("ğŸš€ Real-time events - Setting up event watchers...", {
      timestamp: new Date().toISOString(),
      chainId: chain.id,
      contractAddress: CONTRACTS.daoAgendaManager.address,
      hasUpdateAgendaData: !!updateAgendaData
    });

    const setupEventWatchers = async () => {
      try {
        // ì´ë²¤íŠ¸ ì „ìš© RPC í´ë¼ì´ì–¸íŠ¸ ìƒì„± (ì§€ê°‘ ì—°ê²°ê³¼ ë…ë¦½ì )
        const publicClient = createPublicClient({
          chain: {
            ...chain,
            id: chain.id,
          },
          transport: http(
            process.env.NEXT_PUBLIC_RPC_URL_FOR_EVENT ||
            process.env.NEXT_PUBLIC_RPC_URL ||
            'https://ethereum-sepolia-rpc.publicnode.com'
          ),
        });

        console.log("âœ… Real-time events - Event-specific public client created", {
          eventRpcUrl: process.env.NEXT_PUBLIC_RPC_URL_FOR_EVENT,
          fallbackRpcUrl: process.env.NEXT_PUBLIC_RPC_URL,
          chainId: chain.id
        });

        // AgendaCreated ì´ë²¤íŠ¸ ê°ì§€
        const unwatchAgendaCreated = publicClient.watchEvent({
          address: CONTRACTS.daoAgendaManager.address as `0x${string}`,
          event: {
            type: 'event',
            name: 'AgendaCreated',
            inputs: [
              { name: 'id', type: 'uint256', indexed: true },
              { name: 'from', type: 'address', indexed: true },
              { name: 'noticePeriod', type: 'uint256', indexed: false },
              { name: 'votingPeriod', type: 'uint256', indexed: false },
            ],
          },
          onLogs: (logs) => {
            console.log("ğŸ‰ New AgendaCreated event detected:", logs);
            logs.forEach((log) => {
              const agendaId = Number(log.args.id);
              console.log(`ğŸ“‹ Processing new agenda ID: ${agendaId}`);
              updateAgendaData(agendaId, true); // shouldSort = true for new agendas
            });
          },
        });

        // AgendaVoteCasted ì´ë²¤íŠ¸ ê°ì§€
        const unwatchVoteCasted = publicClient.watchEvent({
          address: CONTRACTS.daoAgendaManager.address as `0x${string}`,
          event: {
            type: 'event',
            name: 'AgendaVoteCasted',
            inputs: [
              { name: 'id', type: 'uint256', indexed: true },
              { name: 'from', type: 'address', indexed: true },
              { name: 'isSupport', type: 'uint8', indexed: false },
              { name: 'stake', type: 'uint256', indexed: false },
            ],
          },
          onLogs: (logs) => {
            console.log("ğŸ—³ï¸ New AgendaVoteCasted event detected:", logs);
            logs.forEach((log) => {
              const agendaId = Number(log.args.id);
              console.log(`ğŸ—³ï¸ Processing vote for agenda ID: ${agendaId}`);
              updateAgendaData(agendaId, false); // shouldSort = false for vote updates
            });
          },
        });

        // AgendaExecuted ì´ë²¤íŠ¸ ê°ì§€
        const unwatchAgendaExecuted = publicClient.watchEvent({
          address: CONTRACTS.daoAgendaManager.address as `0x${string}`,
          event: {
            type: 'event',
            name: 'AgendaExecuted',
            inputs: [
              { name: 'id', type: 'uint256', indexed: true },
              { name: 'from', type: 'address', indexed: true },
            ],
          },
          onLogs: (logs) => {
            console.log("âš¡ New AgendaExecuted event detected:", logs);
            logs.forEach((log) => {
              const agendaId = Number(log.args.id);
              console.log(`âš¡ Processing executed agenda ID: ${agendaId}`);
              updateAgendaData(agendaId, false); // shouldSort = false for execution updates
            });
          },
        });

        console.log("âœ… Real-time events - All event watchers setup complete");

        // Cleanup function
        return () => {
          console.log("ğŸ§¹ Real-time events - Cleaning up event watchers...");
          unwatchAgendaCreated();
          unwatchVoteCasted();
          unwatchAgendaExecuted();
          console.log("âœ… Real-time events - Cleanup complete");
        };
      } catch (error) {
        console.error("âŒ Real-time events - Error setting up event watchers:", error);
      }
    };

    const cleanupPromise = setupEventWatchers();

    return () => {
      cleanupPromise.then((cleanup) => {
        if (cleanup) cleanup();
      });
    };
  }, []); // í•œ ë²ˆë§Œ ì‹¤í–‰ - updateAgendaDataëŠ” ë³€ê²½ë˜ì§€ ì•ŠìŒ

  // VoterInfos ì¡°íšŒ í•¨ìˆ˜
  const getVoterInfos = useCallback(async (agendaId: number, voters: string[]) => {
    try {
      const publicClient = await createRobustPublicClient();

      const voterInfos = await Promise.all(
        voters.map(async (voter) => {
          try {
            const info = await readContractWithRetry(
              () => publicClient.readContract({
                address: CONTRACTS.daoAgendaManager.address as `0x${string}`,
                abi: daoAgendaManagerAbi,
                functionName: 'voterInfos',
                args: [BigInt(agendaId), voter as `0x${string}`],
              }) as Promise<{
                isVoter: boolean;
                hasVoted: boolean;
                vote: bigint;
              }>,
              `Voter info for ${voter}`
            );

            return info;
          } catch (error) {
            console.error(`Failed to get voter info for ${voter}:`, error);
            return {
              isVoter: false,
              hasVoted: false,
              vote: BigInt(0),
            };
          }
        })
      );

      return voterInfos;
    } catch (error) {
      console.error('Failed to get voter infos:', error);
      return [];
    }
  }, []);

  // íŠ¹ì • ì•„ì  ë‹¤ ìƒˆë¡œê³ ì¹¨
  const refreshAgenda = useCallback(async (agendaId: number) => {
    try {
      const publicClient = await createRobustPublicClient();

      const agendaData = await readContractWithRetry(
        () => publicClient.readContract({
          address: CONTRACTS.daoAgendaManager.address as `0x${string}`,
          abi: daoAgendaManagerAbi,
          functionName: 'agendas',
          args: [BigInt(agendaId)],
        }) as Promise<{
          createdTimestamp: bigint;
          noticeEndTimestamp: bigint;
          votingPeriodInSeconds: bigint;
          votingStartedTimestamp: bigint;
          votingEndTimestamp: bigint;
          executableLimitTimestamp: bigint;
          executedTimestamp: bigint;
          countingYes: bigint;
          countingNo: bigint;
          countingAbstain: bigint;
          status: number;
          result: number;
          voters: readonly string[];
          executed: boolean;
        }>,
        `Refresh agenda ${agendaId}`
      );

             // ê¸°ì¡´ agenda ëª©ë¡ì—ì„œ í•´ë‹¹ agendaë§Œ ì—…ë°ì´íŠ¸
       setAgendas(prev => prev.map(agenda =>
         agenda.id === agendaId
           ? {
               ...agenda,
               ...agendaData,
               voters: Array.from(agendaData.voters),
             }
           : agenda
       ));

      console.log(`âœ… Refreshed agenda ${agendaId}`);
    } catch (error) {
      console.error(`Failed to refresh agenda ${agendaId}:`, error);
    }
  }, []);

  // ì•„ì  ë‹¤ ìƒˆë¡œê³ ì¹¨ (ìºì‹œ ì—†ì´)
  const refreshAgendaWithoutCache = useCallback(async (agendaId: number): Promise<AgendaWithMetadata | null> => {
    try {
      const publicClient = await createRobustPublicClient();

      const agendaData = await readContractWithRetry(
        () => publicClient.readContract({
          address: CONTRACTS.daoAgendaManager.address as `0x${string}`,
          abi: daoAgendaManagerAbi,
          functionName: 'agendas',
          args: [BigInt(agendaId)],
        }) as Promise<{
          createdTimestamp: bigint;
          noticeEndTimestamp: bigint;
          votingPeriodInSeconds: bigint;
          votingStartedTimestamp: bigint;
          votingEndTimestamp: bigint;
          executableLimitTimestamp: bigint;
          executedTimestamp: bigint;
          countingYes: bigint;
          countingNo: bigint;
          countingAbstain: bigint;
          status: number;
          result: number;
          voters: readonly string[];
          executed: boolean;
        }>,
        `Get agenda ${agendaId} without cache`
      );

             // ë©”íƒ€ë°ì´í„° ë¡œë”©
      let metadata: AgendaMetadata | null = null;
      try {
        const networkName = getNetworkName(chain.id);
        const metadataUrl = getMetadataUrl(agendaId, networkName);

        const response = await fetch(metadataUrl, {
          cache: "no-store", // ìºì‹œ ë¹„í™œì„±í™”
        });

        if (response.ok) {
          metadata = await response.json();
        }
      } catch (error) {
        console.warn(`Failed to load metadata for agenda ${agendaId}:`, error);
      }

      const updatedAgenda: AgendaWithMetadata = {
         ...agendaData,
         id: agendaId,
         voters: Array.from(agendaData.voters),
         creator: {
           address: metadata ? getCreatorAddress(metadata.creator) : "0x0000000000000000000000000000000000000000" as `0x${string}`,
           signature: metadata ? getCreatorSignature(metadata.creator) : undefined,
         },
         title: metadata?.title || `Agenda #${agendaId}`,
         description: metadata?.description || `Agenda ${agendaId} from blockchain`,
         snapshotUrl: metadata?.snapshotUrl,
         discourseUrl: metadata?.discourseUrl,
         network: metadata?.network,
         transaction: metadata?.transaction,
         actions: metadata?.actions,
       };

      // ê¸°ì¡´ ì•„ì  ë‹¤ ëª©ë¡ ì—…ë°ì´íŠ¸
      setAgendas(prev => {
        const existingAgendas = new Map(prev.map(a => [a.id, a]));
        existingAgendas.set(agendaId, updatedAgenda);
        return Array.from(existingAgendas.values());
      });

      return updatedAgenda;
    } catch (error) {
      console.error(`Failed to refresh agenda without cache ${agendaId}:`, error);
      return null;
    }
  }, []);

  // ì•„ì  ë‹¤ ê°€ì ¸ì˜¤ê¸°
  const getAgenda = useCallback(async (agendaId: number): Promise<AgendaWithMetadata | null> => {
    // ë©”ëª¨ë¦¬ì—ì„œ ì°¾ê¸°
    const existingAgenda = agendas.find(agenda => agenda.id === agendaId);
    if (existingAgenda) {
      return existingAgenda;
    }

    // ë©”ëª¨ë¦¬ì— ì—†ìœ¼ë©´ ë¸”ë¡ì²´ì¸ì—ì„œ ê°€ì ¸ì˜¤ê¸°
    return await refreshAgendaWithoutCache(agendaId);
  }, [agendas, refreshAgendaWithoutCache]);

  // ì „ì²´ ì•„ì  ë‹¤ ìƒˆë¡œê³ ì¹¨
  const refreshAgendas = useCallback(async () => {
    setHasLoadedOnce(false);
    await loadAgendas();
  }, [loadAgendas]);

  // íŠ¸ëœì­ì…˜ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
  const getTransactionData = useCallback(async (txHash: string): Promise<string | null> => {
    try {
      const publicClient = await createRobustPublicClient();

      const transaction = await publicClient.getTransaction({
        hash: txHash as `0x${string}`
      });

      return transaction.input;
    } catch (error) {
      console.error(`Failed to get transaction data for ${txHash}:`, error);
      return null;
    }
  }, []);

  // ì•„ì  ë‹¤ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
  const updateAgendaCalldata = useCallback(async (agendaId: number) => {
    try {
      const agenda = await getAgenda(agendaId);
      if (agenda && agenda.transaction) {
        const calldata = await getTransactionData(agenda.transaction);
        if (calldata) {
          setAgendas(prev => prev.map(agenda =>
            agenda.id === agendaId
              ? {
                  ...agenda,
                  creationCalldata: calldata,
                }
              : agenda
          ));
        }
      }
    } catch (error) {
      console.error(`Failed to update agenda ${agendaId} calldata:`, error);
    }
  }, [getAgenda, getTransactionData]);

  const contextValue = useMemo(() => ({
    agendas,
    isLoading,
    error,
    refreshAgendas,
    refreshAgenda,
    refreshAgendaWithoutCache,
    getAgenda,
    statusMessage,
    contract: {
      address: CONTRACTS.daoAgendaManager.address as `0x${string}`,
      abi: daoAgendaManagerAbi,
      chainId: chain.id,
    },
    daoContract: {
      address: CONTRACTS.daoCommittee.address as `0x${string}`,
      abi: DAO_ABI,
      chainId: chain.id,
    },
    events,
    isPolling,
    progress,
    createAgendaFees,
    minimumNoticePeriodSeconds,
    minimumVotingPeriodSeconds,
    quorum,
    getVoterInfos,
    getTransactionData,
    updateAgendaCalldata,
  }), [
    agendas,
    isLoading,
    error,
    refreshAgendas,
    refreshAgenda,
    refreshAgendaWithoutCache,
    getAgenda,
    statusMessage,
    events,
    isPolling,
    progress,
    createAgendaFees,
    minimumNoticePeriodSeconds,
    minimumVotingPeriodSeconds,
    quorum,
    getVoterInfos,
    getTransactionData,
    updateAgendaCalldata,
  ]);

  return (
    <AgendaContext.Provider value={contextValue}>
      {children}
    </AgendaContext.Provider>
  );
});

// React.memo ì»´í¬ë„ŒíŠ¸ì— displayName ì¶”ê°€
AgendaProviderComponent.displayName = 'AgendaProvider';

// ë©”ëª¨ì´ì œì´ì…˜ëœ ì»´í¬ë„ŒíŠ¸ë¥¼ export
export const AgendaProvider = AgendaProviderComponent;

export function useAgenda() {
  const context = useContext(AgendaContext);
  if (context === undefined) {
    throw new Error("useAgenda must be used within an AgendaProvider");
  }
  return context;
}