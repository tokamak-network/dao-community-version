export interface GitHubConfig {
  username: string
  token: string
  owner: string
  repo: string
  branch: string
}

export interface PRData {
  title: string
  body: string
  head: string
  base: string
  files: {
    path: string
    content: string
  }[]
}

export interface AgendaMetadata {
  id: number
  title: string
  description: string
  network: 'mainnet' | 'sepolia'
  transaction: string
  creator: {
    address: string
    signature: string
  }
  actions: Action[]
  createdAt: string
  updatedAt?: string
  snapshotUrl?: string
  discourseUrl?: string
}

export interface Action {
  title: string
  contractAddress: string
  method: string
  calldata: string
  abi?: any[]
  sendEth?: boolean
  id?: string
  type?: string
}

export const GITHUB_CONFIG: Partial<GitHubConfig> = {
  owner: 'tokamak-network',
  repo: 'dao-agenda-metadata-repository',
  branch: 'main'
}

export const createPR = async (
  config: GitHubConfig,
  metadata: AgendaMetadata,
  isUpdate: boolean = false
): Promise<string> => {
  const octokit = await import('@octokit/rest').then(m => new m.Octokit({
    auth: config.token
  }))

  try {
    // 1. Fork the repository (if needed)
    let fork
    try {
      fork = await octokit.repos.get({
        owner: config.username,
        repo: config.repo
      })
    } catch {
      // Fork doesn't exist, create it
      await octokit.repos.createFork({
        owner: config.owner,
        repo: config.repo
      })

      // Wait for fork to be ready
      await new Promise(resolve => setTimeout(resolve, 3000))
      
      fork = await octokit.repos.get({
        owner: config.username,
        repo: config.repo
      })
    }

    // 2. Create a new branch
    const branchName = `agenda-${metadata.id}-${metadata.network}-${Date.now()}`
    
    // Get the default branch SHA
    const defaultBranch = await octokit.repos.getBranch({
      owner: config.username,
      repo: config.repo,
      branch: config.branch
    })

    // Create the new branch
    await octokit.git.createRef({
      owner: config.username,
      repo: config.repo,
      ref: `refs/heads/${branchName}`,
      sha: defaultBranch.data.commit.sha
    })

    // 3. Upload file
    const filePath = `data/agendas/${metadata.network}/agenda-${metadata.id}.json`
    const fileContent = Buffer.from(JSON.stringify(metadata, null, 2)).toString('base64')

    // Check if file exists
    let existingFile
    try {
      existingFile = await octokit.repos.getContent({
        owner: config.username,
        repo: config.repo,
        path: filePath,
        ref: branchName
      })
    } catch {
      // File doesn't exist, which is fine
    }

    // Create or update the file
    await octokit.repos.createOrUpdateFileContents({
      owner: config.username,
      repo: config.repo,
      path: filePath,
      message: `${isUpdate ? 'Update' : 'Add'} metadata for agenda ${metadata.id} on ${metadata.network}`,
      content: fileContent,
      branch: branchName,
      sha: existingFile ? (existingFile.data as any).sha : undefined
    })

    // 4. Create PR
    const pr = await octokit.pulls.create({
      owner: config.owner,
      repo: config.repo,
      title: generatePRTitle(metadata.network, metadata.id, metadata.title, isUpdate),
      body: generatePRBody(metadata, isUpdate),
      head: `${config.username}:${branchName}`,
      base: config.branch
    })

    return pr.data.html_url
  } catch (error: any) {
    throw new Error(`Failed to create PR: ${error.message}`)
  }
}

export const generatePRTitle = (
  network: string,
  agendaId: number,
  title: string,
  isUpdate: boolean = false
): string => {
  const prefix = isUpdate ? '[Agenda Update]' : '[Agenda]'
  return `${prefix} ${network} - ${agendaId} - ${title}`
}

export const generatePRBody = (
  metadata: AgendaMetadata,
  isUpdate: boolean = false
): string => {
  const action = isUpdate ? 'Update' : 'Add'
  
  return `## ${action} Agenda Metadata

### Agenda Information
- **ID**: ${metadata.id}
- **Network**: ${metadata.network}
- **Title**: ${metadata.title}
- **Transaction**: ${metadata.transaction}
- **Creator**: ${metadata.creator.address}

### Description
${metadata.description}

### Actions
${metadata.actions.map((action, index) => 
  `${index + 1}. **${action.title || `Action ${index + 1}`}**
   - Contract: ${action.contractAddress}
   - Method: ${action.method}`
).join('\n')}

### Additional Links
${metadata.snapshotUrl ? `- [Snapshot](${metadata.snapshotUrl})` : ''}
${metadata.discourseUrl ? `- [Discourse](${metadata.discourseUrl})` : ''}

### Verification
- Signature verified âœ…
- Timestamp: ${metadata.createdAt}
${isUpdate ? `- Updated at: ${metadata.updatedAt}` : ''}

---
*This PR was automatically generated by the Tokamak DAO Agenda Metadata Generator*`
}

export const validateGitHubToken = async (
  username: string,
  token: string
): Promise<boolean> => {
  try {
    const octokit = await import('@octokit/rest').then(m => new m.Octokit({
      auth: token
    }))

    const user = await octokit.users.getAuthenticated()
    return user.data.login.toLowerCase() === username.toLowerCase()
  } catch {
    return false
  }
}