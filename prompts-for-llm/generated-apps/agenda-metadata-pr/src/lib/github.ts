import { Octokit } from '@octokit/rest'
import { GitHubConfig, PRData, AgendaMetadata } from '@/types/agenda'

export const GITHUB_CONFIG: GitHubConfig = {
  username: '',
  token: '',
  owner: 'tokamak-network',
  repo: 'dao-agenda-metadata-repository',
  branch: 'main'
}

export const generatePRTitle = (
  network: string,
  agendaId: number,
  title: string,
  isUpdate: boolean = false
): string => {
  const prefix = isUpdate ? '[Agenda Update]' : '[Agenda]'
  return `${prefix} ${network} - ${agendaId} - ${title}`
}

export const generatePRBody = (
  metadata: AgendaMetadata,
  isUpdate: boolean = false
): string => {
  const action = isUpdate ? 'Update' : 'Add'
  
  return `## ${action} Agenda Metadata

### Agenda Information
- **ID**: ${metadata.id}
- **Title**: ${metadata.title}
- **Network**: ${metadata.network}
- **Transaction**: ${metadata.transaction}
- **Creator**: ${metadata.creator.address}

### Description
${metadata.description}

### Actions
${metadata.actions.map((action, index) => `
${index + 1}. **${action.title || `Action ${index + 1}`}**
   - Contract: ${action.contractAddress}
   - Method: ${action.method}
`).join('')}

### Additional Links
${metadata.snapshotUrl ? `- Snapshot: ${metadata.snapshotUrl}` : ''}
${metadata.discourseUrl ? `- Discourse: ${metadata.discourseUrl}` : ''}

### Validation
- ✅ Schema validation passed
- ✅ Signature verified
- ✅ Timestamp validated (within 1 hour)
- ✅ Data integrity confirmed

---
*This PR was automatically generated by the Tokamak DAO Agenda Metadata Generator*`
}

export const validateGitHubToken = async (
  username: string,
  token: string
): Promise<boolean> => {
  try {
    const octokit = new Octokit({ auth: token })
    const { data } = await octokit.users.getAuthenticated()
    return data.login.toLowerCase() === username.toLowerCase()
  } catch {
    return false
  }
}

export const createPR = async (
  config: GitHubConfig,
  metadata: AgendaMetadata,
  isUpdate: boolean = false
): Promise<string> => {
  const octokit = new Octokit({ auth: config.token })
  
  try {
    // 1. Check if fork exists
    let fork
    try {
      const { data } = await octokit.repos.get({
        owner: config.username,
        repo: config.repo
      })
      fork = data
    } catch {
      // Fork doesn't exist, create it
      const { data } = await octokit.repos.createFork({
        owner: config.owner,
        repo: config.repo
      })
      fork = data
      
      // Wait for fork to be ready
      await new Promise(resolve => setTimeout(resolve, 3000))
    }
    
    // 2. Get base branch
    const { data: baseBranch } = await octokit.repos.getBranch({
      owner: config.owner,
      repo: config.repo,
      branch: config.branch
    })
    
    // 3. Create new branch
    const branchName = `agenda-${metadata.id}-${metadata.network}-${Date.now()}`
    await octokit.git.createRef({
      owner: config.username,
      repo: config.repo,
      ref: `refs/heads/${branchName}`,
      sha: baseBranch.commit.sha
    })
    
    // 4. Create/update file
    const filePath = `data/agendas/${metadata.network}/agenda-${metadata.id}.json`
    const fileContent = Buffer.from(JSON.stringify(metadata, null, 2)).toString('base64')
    
    let existingFile
    try {
      const { data } = await octokit.repos.getContent({
        owner: config.username,
        repo: config.repo,
        path: filePath,
        ref: branchName
      })
      if (!Array.isArray(data) && 'sha' in data) {
        existingFile = data
      }
    } catch {
      // File doesn't exist, that's ok for new agenda
    }
    
    await octokit.repos.createOrUpdateFileContents({
      owner: config.username,
      repo: config.repo,
      path: filePath,
      message: isUpdate 
        ? `Update metadata for agenda ${metadata.id} on ${metadata.network}`
        : `Add metadata for agenda ${metadata.id} on ${metadata.network}`,
      content: fileContent,
      branch: branchName,
      sha: existingFile?.sha
    })
    
    // 5. Create PR
    const { data: pr } = await octokit.pulls.create({
      owner: config.owner,
      repo: config.repo,
      title: generatePRTitle(metadata.network, metadata.id, metadata.title, isUpdate),
      body: generatePRBody(metadata, isUpdate),
      head: `${config.username}:${branchName}`,
      base: config.branch
    })
    
    return pr.html_url
  } catch (error) {
    console.error('Error creating PR:', error)
    throw new Error(`Failed to create PR: ${error instanceof Error ? error.message : 'Unknown error'}`)
  }
}

export const checkExistingMetadata = async (
  config: GitHubConfig,
  network: string,
  agendaId: number
): Promise<AgendaMetadata | null> => {
  try {
    const octokit = new Octokit({ auth: config.token })
    const filePath = `data/agendas/${network}/agenda-${agendaId}.json`
    
    const { data } = await octokit.repos.getContent({
      owner: config.owner,
      repo: config.repo,
      path: filePath
    })
    
    if (!Array.isArray(data) && 'content' in data) {
      const content = Buffer.from(data.content, 'base64').toString('utf-8')
      return JSON.parse(content) as AgendaMetadata
    }
    
    return null
  } catch {
    return null
  }
}